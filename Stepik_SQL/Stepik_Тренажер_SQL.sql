# CREATE DATABASE stepik;

USE stepik;
CREATE TABLE trip
    (
        trip_id INT
            PRIMARY KEY AUTO_INCREMENT,
        name VARCHAR(30),
        city VARCHAR(25),
        per_diem DECIMAL(8, 2),
        date_first DATE,
        date_last DATE
    );

INSERT INTO trip(name, city, per_diem, date_first, date_last)
VALUES ('Баранов П.Е.', 'Москва', 700, '2020-01-12', '2020-01-17'),
       ('Абрамова К.А.', 'Владивосток', 450, '2020-01-14', '2020-01-27'),
       ('Семенов И.В.', 'Москва', 700, '2020-01-23', '2020-01-31'),
       ('Ильиных Г.Р.', 'Владивосток', 450, '2020-01-12', '2020-02-02'),
       ('Колесов С.П.', 'Москва', 700, '2020-02-01', '2020-02-06'),
       ('Баранов П.Е.', 'Москва', 700, '2020-02-14', '2020-02-22'),
       ('Абрамова К.А.', 'Москва', 700, '2020-02-23', '2020-03-01'),
       ('Лебедев Т.К.', 'Москва', 700, '2020-03-03', '2020-03-06'),
       ('Колесов С.П.', 'Новосибирск', 450, '2020-02-27', '2020-03-12'),
       ('Семенов И.В.', 'Санкт-Петербург', 700, '2020-03-29', '2020-04-05'),
       ('Абрамова К.А.', 'Москва', 700, '2020-04-06', '2020-04-14'),
       ('Баранов П.Е.', 'Новосибирск', 450, '2020-04-18', '2020-05-04'),
       ('Лебедев Т.К.', 'Томск', 450, '2020-05-20', '2020-05-31'),
       ('Семенов И.В.', 'Санкт-Петербург', 700, '2020-06-01', '2020-06-03'),
       ('Абрамова К.А.', 'Санкт-Петербург', 700, '2020-05-28', '2020-06-04'),
       ('Федорова А.Ю.', 'Новосибирск', 450, '2020-05-25', '2020-06-04'),
       ('Колесов С.П.', 'Новосибирск', 450, '2020-06-03', '2020-06-12'),
       ('Федорова А.Ю.', 'Томск', 450, '2020-06-20', '2020-06-26'),
       ('Абрамова К.А.', 'Владивосток', 450, '2020-07-02', '2020-07-13'),
       ('Баранов П.Е.', 'Воронеж', 450, '2020-07-19', '2020-07-25');

SELECT *
  FROM trip;


# Вывести из таблицы trip информацию о командировках тех сотрудников, фамилия которых
# заканчивается на букву «а», в отсортированном по убыванию даты последнего дня командировки виде.
# В результат включить столбцы NAME, city, per_diem, date_first, date_last.
#
# +---------------+-----------------+----------+------------+------------+
# | NAME          | city            | per_diem | date_first | date_last  |
# +---------------+-----------------+----------+------------+------------+
# | Абрамова К.А. | Владивосток     | 450.00   | 2020-07-02 | 2020-07-13 |
# | Федорова А.Ю. | Томск           | 450.00   | 2020-06-20 | 2020-06-26 |
# | Абрамова К.А. | Санкт-Петербург | 700.00   | 2020-05-28 | 2020-06-04 |
# | Федорова А.Ю. | Новосибирск     | 450.00   | 2020-05-25 | 2020-06-04 |
# | Абрамова К.А. | Москва          | 700.00   | 2020-04-06 | 2020-04-14 |
# | Абрамова К.А. | Москва          | 700.00   | 2020-02-23 | 2020-03-01 |
# | Абрамова К.А. | Владивосток     | 450.00   | 2020-01-14 | 2020-01-27 |
# +---------------+-----------------+----------+------------+------------+

SELECT name, city, per_diem, date_first, date_last
  FROM trip
 WHERE name LIKE '%а %'
 ORDER BY date_last DESC;

/*
Вывести в алфавитном порядке фамилии и инициалы тех сотрудников, которые были в командировке в Москве.
Результат
+---------------+
| name          |
+---------------+
| Абрамова К.А. |
| Баранов П.Е.  |
| Колесов С.П.  |
| Лебедев Т.К.  |
| Семенов И.В.  |
+---------------+
 */

SELECT DISTINCT name
  FROM trip
 WHERE city = 'Москва'
 ORDER BY name;

/*
Для каждого города посчитать, сколько раз сотрудники в нем были.
Информацию вывести в отсортированном в алфавитном порядке по названию городов.
Вычисляемый столбец назвать Количество.

Результат

+-----------------+------------+
| city            | Количество |
+-----------------+------------+
| Владивосток     | 3          |
| Воронеж         | 1          |
| Москва          | 7          |
| Новосибирск     | 4          |
| Санкт-Петербург | 3          |
| Томск           | 2          |
+-----------------+------------+

*/

SELECT city, COUNT(city) AS количество
  FROM trip
 GROUP BY city
 ORDER BY city;

/*
Вывести фамилию, номер машины и нарушение только для тех водителей, которые
на одной машине нарушили одно и то же правило два и более раз.
При этом учитывать все нарушения, независимо от того оплачены они или нет.

Информацию отсортировать в алфавитном порядке, сначала по фамилии водителя,
потом по номеру машины и, наконец, по нарушению.

Пояснение

Под увеличение  штрафа в два раза подходит водитель «Абрамова К.А.»,
который на машине с государственным номером «О111АВ» совершил повторное нарушение
«Проезд на запрещающий сигнал», а также водитель  «Баранов П.Е.» ,
который на машине с номером  «Р523ВТ» дважды совершил нарушение «Превышение скорости(от 40 до 60)».
+---------------+--------------+----------------------------------+
| name          | number_plate | violation                        |
+---------------+--------------+----------------------------------+
| Абрамова К.А. | О111АВ       | Проезд на запрещающий сигнал     |
| Баранов П.Е.  | Р523ВТ       | Превышение скорости(от 40 до 60) |
+---------------+--------------+----------------------------------+

Связанные шаги
    выборка столбцов;
    условие отбора в запросах группировки ;
    сортировка.
 */

SELECT name, number_plate, violation, COUNT(violation) AS количество
  FROM fine
 GROUP BY name, number_plate, violation
HAVING COUNT(violation) > 1;

/*
В таблице fine увеличить в два раза сумму неоплаченных штрафов для отобранных на предыдущем шаге записей.

    Для всех нарушений, по которым штраф еще не оплачен, (тех, у которых date_payment имеет пустое значение Null),
    необходимо проверить, является ли данное нарушение для водителя и машины повторным, если да –  увеличить штраф в два раза.

    Если водитель совершил нарушение на другой машине, ему увеличивать штраф не нужно.
    Если несколько повторных нарушений не оплачены, то штраф увеличить для всех.
    Этот запрос реализован на предыдущем шаге.

При реализации можно использовать вложенный запрос как отдельную таблицу, записанную после ключевого слова UPDATE,
при этом вложенному запросу необходимо присвоить имя, например query_in:

UPDATE fine, ( SELECT ... ) query_in
    SET ...
        WHERE
указать, что совпадают нарушение, фамилия водителя и номер машины в таблицах fine и
вложенном запросе query_in соответственно, а также дата оплаты в таблице fine пуста


Важно! Если в запросе используется несколько таблиц или запросов, включающих одинаковые поля,
то применяется полное имя столбца, включающего название таблицы через символ «.».
Например,  fine.name  и  query_in.name.

Результат
Affected rows: 2

Query result:
+---------------+--------------+----------------------------------+----------+------------------+--------------+
| name          | number_plate | violation                        | sum_fine | date_violation   | date_payment |
+---------------+--------------+----------------------------------+----------+------------------+--------------+
| Баранов П.Е.  | Р523ВТ       | Превышение скорости(от 40 до 60) | 500.00   | 2020-01-12       | 2020-01-17   |
| Абрамова К.А. | О111АВ       | Проезд на запрещающий сигнал     | 1000.00  | 2020-01-14       | 2020-02-27   |
| Яковлев Г.Р.  | Т330ТТ       | Превышение скорости(от 20 до 40) | 500.00   | 2020-01-23       | 2020-02-23   |
| Яковлев Г.Р.  | М701АА       | Превышение скорости(от 20 до 40) | 500.00   | 2020-01-12       | NULL        |
| Колесов С.П.  | К892АХ       | Превышение скорости(от 20 до 40) | 500.00   | 2020-02-01       | NULL         |
| Баранов П.Е.  | Р523ВТ       | Превышение скорости(от 40 до 60) | 2000.00  | 2020-02-14       | NULL         |
| Абрамова К.А. | О111АВ       | Проезд на запрещающий сигнал     | 2000.00  | 2020-02-23       | NULL         |
| Яковлев Г.Р.  | Т330ТТ       | Проезд на запрещающий сигнал     | 1000.00  | 2020-03-03       | NULL         |
+---------------+--------------+----------------------------------+----------+------------------+--------------+

Связанные шаги
    обновление данных (шаг, шаг, шаг);
    условие отбора.
*/
UPDATE fine f, (SELECT name, number_plate, violation
                  FROM fine
                 GROUP BY name, number_plate, violation
                HAVING COUNT(violation) > 1) q_in
   SET f.sum_fine = f.sum_fine * 2
 WHERE f.date_payment IS NULL
   AND f.violation = q_in.violation
   AND f.name = q_in.name
   AND f.number_plate = q_in.number_plate;

/*
  Водители оплачивают свои штрафы. В таблице payment занесены даты их оплаты:
Необходимо:
    - в таблицу fine занести дату оплаты соответствующего штрафа из таблицы payment;
    - уменьшить начисленный штраф в таблице fine в два раза  (только для тех штрафов,
      информация о которых занесена в таблицу payment) , если оплата произведена
      не позднее 20 дней со дня нарушения.

Пояснение к заданию
1. Для уменьшения суммы штрафа в два раза в зависимости от условия можно  использовать функцию if().
Синтаксис раздела SET при использовании функции if() следующий:

SET столбец = IF(условие, выражение_1, выражение_2)

Выполняется этот оператор так:
    сначала вычисляется условие;
    если условие ИСТИНА, то вычисляется выражение_1, в противном случае (если условие ЛОЖНО) вычисляется выражение_2;
    в столбец заносится результат выполнения функции (либо значение выражения_1, либо значение выражения_2 в зависимости от условия).

Например, чтобы обнулить штрафы, меньшие или равные 500 рублей, а остальные оставить без изменения, используется запрос:

UPDATE fine
SET sum_fine = IF(sum_fine <= 500, 0, sum_fine)

2. Количество дней между датой нарушения и датой оплаты считается по формуле:

количество_дней = дата_оплаты - дата_нарушения
Пояснение к решению  !!! раскройте пояснение, если не получается решить или ошибка в запросе !!!

Шаблон запроса:

UPDATE
    fine, payment
SET
    fine.date_payment = дата оплаты из payment,
    fine.sum_fine = сравнить разницу между датой нарушения и датой оплаты (из payment)
                    и при необходимости уменьшить размер штрафа (использовать IF)
WHERE
    указать условие, что совпадают и номера машин, и нарушения, и
    фамилия водителя в таблицах fine и payment, а также, что
    дата оплаты в fine должна быть пуста

Результат

Affected rows: 3
Query result:
+---------------+--------+----------------------------------+----------+---------------------------+
| name          | number_| violation                        | sum_fine | date_      | date_payment |
|               |  plate |                                  |          | violation  |              |
+---------------+--------+----------------------------------+----------+------------+--------------+
| Баранов П.Е.  | Р523ВТ | Превышение скорости(от 40 до 60) | 500.00   | 2020-01-12 | 2020-01-17   |
| Абрамова К.А. | О111АВ | Проезд на запрещающий сигнал     | 1000.00  | 2020-01-14 | 2020-02-27   |
| Яковлев Г.Р.  | Т330ТТ | Превышение скорости(от 20 до 40) | 500.00   | 2020-01-23 | 2020-02-23   |
| Яковлев Г.Р.  | М701АА | Превышение скорости(от 20 до 40) | 250.00   | 2020-01-12 | 2020-01-22   |
| Колесов С.П.  | К892АХ | Превышение скорости(от 20 до 40) | 500.00   | 2020-02-01 | NULL         |
| Баранов П.Е.  | Р523ВТ | Превышение скорости(от 40 до 60) | 2000.00  | 2020-02-14 | 2020-03-06   |
| Абрамова К.А. | О111АВ | Проезд на запрещающий сигнал     | 2000.00  | 2020-02-23 | NULL         |
| Яковлев Г.Р.  | Т330ТТ | Проезд на запрещающий сигнал     | 500.00   | 2020-03-03 | 2020-03-23   |
+---------------+--------+----------------------------------+----------+------------+--------------+

Связанные шаги

    обновление данных (шаг, шаг, шаг);
    функция IF();
    вычитание дат;
    условие отбора.

 */

CREATE TABLE payment
    (
        payment_id INT AUTO_INCREMENT
            PRIMARY KEY,
        name VARCHAR(30) NULL,
        number_plate VARCHAR(6) NULL,
        violation VARCHAR(50) NULL,
        date_violation DATE NULL,
        date_payment DATE NULL
    );

INSERT payment (name, number_plate, violation, date_violation, date_payment)
VALUES ('Яковлев Г.Р.', 'M701AA', 'Превышение скорости(от 20 до 40)', '2020-01-12', '2020-01-22'),
       ('Баранов П.Е.', 'P523BT', 'Превышение скорости(от 40 до 60)', '2020-02-14', '2020-03-06'),
       ('Яковлев Г.Р.', 'T330TT', 'Проезд на запрещающий сигнал', '2020-03-03', '2020-03-23');


UPDATE fine f, payment p
   SET f.date_payment = p.date_payment,
       f.sum_fine = IF(DATEDIFF(p.date_payment, f.date_violation) < 21, f.sum_fine / 2, f.sum_fine)
 WHERE f.date_payment IS NULL
   AND f.name = p.name
   AND f.violation = p.violation
   AND f.number_plate = p.number_plate;

/*
Удалить из таблицы fine информацию о нарушениях, совершенных раньше 1 февраля 2020 года. 
Query result
+---------------+--------+------------------------------+----------+----------------+--------------+
| name          | number | violation                    | sum_fine | date_violation | date_payment |
|               | _plate |                              |          |                |              |
+---------------+--------+------------------------------+----------+----------------+--------------+
| Колесов С.П.  | К892АХ | Превышение скорости(от 20... | 500.00   | 2020-02-01     | NULL         |
| Баранов П.Е.  | Р523ВТ | Превышение скорости(от 40... | 2000.00  | 2020-02-14     | 2020-03-05   |
| Абрамова К.А. | О111АВ | Проезд на запрещающий сигн...| 2000.00  | 2020-02-23     | NULL         |
| Яковлев Г.Р.  | Т330ТТ | Проезд на запрещающий сигн...| 500.00   | 2020-03-03     | 2020-03-22   |
+---------------+--------+------------------------------+----------+----------------+--------------+

Связанные шаги
    удаление строк из таблицы;
    условие отбора.
 */

DELETE
  FROM fine
 WHERE date_violation < '2020-02-01';

/*
Создать таблицу author следующей структуры:
author_id 	INT PRIMARY KEY AUTO_INCREMENT
name_author 	VARCHAR(50)
 */

CREATE TABLE author
    (
        author_id INT
            PRIMARY KEY AUTO_INCREMENT,
        name_author VARCHAR(50)
    );

/*
 Заполнить таблицу author. В нее включить следующих авторов:
    Булгаков М.А.
    Достоевский Ф.М.
    Есенин С.А.
    Пастернак Б.Л.

 */

INSERT INTO author (name_author)
VALUES ('Булгаков М.А.'),
       ('Достоевский Ф.М.'),
       ('Есенин С.А.'),
       ('Пастернак Б.Л.');

/*
Перепишите запрос на создание таблицы book , чтобы ее структура соответствовала структуре,
показанной на логической схеме (таблица genre уже создана, порядок следования столбцов -
как на логической схеме в таблице book, genre_id  - внешний ключ) .
Для genre_id ограничение о недопустимости пустых значений не задавать.

В качестве главной таблицы для описания поля  genre_id
использовать таблицу genre следующей структуры:

genre_id 	INT PRIMARY KEY AUTO_INCREMENT
name_genre 	VARCHAR(30)

 */
CREATE TABLE genre
    (
        genre_id INT
            PRIMARY KEY AUTO_INCREMENT,
        name_genre VARCHAR(50)
    );

CREATE TABLE book
    (
        book_id INT
            PRIMARY KEY AUTO_INCREMENT,
        title VARCHAR(50),
        author_id INT NOT NULL,
        genre_id INT,
        price DECIMAL(8, 2),
        amount INT,
        FOREIGN KEY (author_id) REFERENCES author (author_id),
        FOREIGN KEY (genre_id) REFERENCES genre (genre_id)
    );

DESCRIBE book;


CREATE TABLE author
    (
        author_id INT
            PRIMARY KEY AUTO_INCREMENT,
        name_author VARCHAR(50)
    );

INSERT INTO author (name_author)
VALUES ('Булгаков М.А.'),
       ('Достоевский Ф.М.'),
       ('Есенин С.А.'),
       ('Пастернак Б.Л.');

CREATE TABLE genre
    (
        genre_id INT
            PRIMARY KEY AUTO_INCREMENT,
        name_genre VARCHAR(30)
    );

INSERT INTO genre (name_genre)
VALUES ('Роман'),
       ('Поэзия'),
       ('Приключения');

CREATE TABLE book
    (
        book_id INT
            PRIMARY KEY AUTO_INCREMENT,
        title VARCHAR(50),
        author_id INT,
        genre_id INT,
        price DECIMAL(8, 2),
        amount INT,
        FOREIGN KEY (author_id) REFERENCES author (author_id) ON DELETE CASCADE,
        FOREIGN KEY (genre_id) REFERENCES genre (genre_id) ON DELETE SET NULL
    );

INSERT INTO book (title, author_id, genre_id, price, amount)
VALUES ('Мастер и Маргарита', 1, 1, 670.99, 3),
       ('Белая гвардия ', 1, 1, 540.50, 5),
       ('Идиот', 2, 1, 460.00, 10),
       ('Братья Карамазовы', 2, 1, 799.01, 3),
       ('Игрок', 2, 1, 480.50, 10),
       ('Стихотворения и поэмы', 3, 2, 650.00, 15),
       ('Черный человек', 3, 2, 570.20, 6),
       ('Лирика', 4, 2, 518.99, 2);

/*
Вывести название, жанр и цену тех книг, количество которых больше 8, в отсортированном по убыванию цены виде.
Результат
+-----------------------+------------+--------+
| title                 | name_genre | price  |
+-----------------------+------------+--------+
| Стихотворения и поэмы | Поэзия     | 650.00 |
| Игрок                 | Роман      | 480.50 |
| Идиот                 | Роман      | 460.00 |
+-----------------------+------------+--------+
 */

SELECT title, name_genre, price
  FROM genre
           JOIN book
           ON genre.genre_id = book.genre_id AND book.amount > 8
 ORDER BY price DESC;

/*
 Вывести название всех книг каждого автора, если книг некоторых авторов
 в данный момент нет на складе – вместо названия книги указать Null.

+------------------+-----------------------+
| name_author      | title                 |
+------------------+-----------------------+
| Булгаков М.А.    | Мастер и Маргарита    |
| Булгаков М.А.    | Белая гвардия         |
| Достоевский Ф.М. | Игрок                 |
| Достоевский Ф.М. | Идиот                 |
| Достоевский Ф.М. | Братья Карамазовы     |
| Есенин С.А.      | Стихотворения и поэмы |
| Есенин С.А.      | Черный человек        |
| Лермонтов М.Ю.   | NULL                  |
| Пастернак Б.Л.   | Лирика                |
+------------------+-----------------------+

Так как в таблице book нет книг Лермонтова, напротив этой фамилии стоит Null
 */
SELECT name_author, title
  FROM author
           LEFT JOIN book
           ON author.author_id = book.author_id
 ORDER BY name_author;

/*
Вывести все жанры, которые не представлены в книгах на складе.
Результат

+-------------+
| name_genre  |
+-------------+
| Приключения |
+-------------+
 */

SELECT name_genre
  FROM genre
           LEFT JOIN book
           ON genre.genre_id = book.genre_id
 WHERE book.title IS NULL;

/*
Оператор перекрёстного соединения, или декартова произведения CROSS JOIN
в запросе вместо ключевых слов можно поставить запятую между таблицами)
соединяет две таблицы.
Порядок таблиц для оператора неважен, поскольку оператор является симметричным.
Его структура:
SELECT
 ...
FROM
    таблица_1 CROSS JOIN  таблица_2
...
или

SELECT
 ...
FROM
    таблица_1, таблица_2
...

Результат запроса формируется так: каждая строка одной таблицы соединяется
с каждой строкой другой таблицы, формируя  в результате все возможные сочетания строк двух таблиц.

Например, запрос:

SELECT name_author, name_genre
FROM
    author, genre;

каждому автору из таблицы author поставит в соответствие все возможные жанры из таблицы genre:
+------------------+-------------+
| name_author      | name_genre  |
+------------------+-------------+
| Булгаков М.А.    | Роман       |
| Булгаков М.А.    | Поэзия      |
| Булгаков М.А.    | Приключения |
| Достоевский Ф.М. | Роман       |
| Достоевский Ф.М. | Поэзия      |
| Достоевский Ф.М. | Приключения |
| Есенин С.А.      | Роман       |
| Есенин С.А.      | Поэзия      |
| Есенин С.А.      | Приключения |
| Пастернак Б.Л.   | Роман       |
| Пастернак Б.Л.   | Поэзия      |
| Пастернак Б.Л.   | Приключения |
| Лермонтов М.Ю.   | Роман       |
| Лермонтов М.Ю.   | Поэзия      |
| Лермонтов М.Ю.   | Приключения |
+------------------+-------------+
*/
SELECT name_author, name_genre
  FROM author,
       genre;

/*
 Есть список городов, хранящийся в таблице city:
city_id name_city
1 	Москва
2 	Санкт-Петербург
3 	Владивосток

Необходимо в каждом городе провести выставку книг каждого автора в течение 2020 года.
Дату проведения выставки выбрать случайным образом.
Создать запрос, который выведет город, автора и дату проведения выставки.
Последний столбец назвать Дата.
Информацию вывести, отсортировав сначала в алфавитном порядке по названиям городов,
 а потом по убыванию дат проведения выставок.

Структура таблицы:

Пояснение
1. Для генерации случайной даты можно к первому числу года ('2020-01-01') прибавить целое случайное число
 в интервале от 0 до 365.

Генерации случайных чисел в интервале от 0 до 1 (не включительно) осуществляется с помощью функции RAND().
Если эту функцию умножить на 365, то она будет генерировать вещественные числа от 0 до 365 (не включительно).
Осталось только отбросить дробную часть. Это можно сделать с помощью функции FLOOR(), которая возвращает
наибольшее целое число, меньшее или равное указанному числовому значению.
Таким образом, случайное число от 0 до 365 можно получить с помощью выражения:

 FLOOR(RAND() * 365)

Важно! Даты должны быть за 2020 год, первое число года - 1 января 2020 года.

2. Для сложения  даты с числом используется функция:
DATE_ADD(дата, INTERVAL число единица_измерения),
где
  единица_измерения (использовать прописные буквы) – это день (DAY), месяц(MONTH), неделя(WEEK) и пр.,
  число – целое число,
  дата – значение даты или даты и времени.

Функция к дате  прибавляет указанное число, выраженное в днях, месяцах и пр. ,
в зависимости от заданного интервала, и возвращает новую дату.

Например:

DATE_ADD('2020-02-02', INTERVAL 45 DAY) возвращает 18 марта 2020 года
DATE_ADD('2020-02-02', INTERVAL 6 MONTH) возвращает 2 августа 2020 года

Результат

Примечание: даты при каждом запуске получаются разными, и не должны совпадать с приведенными значениями.

+-----------------+------------------+------------+
| name_city       | name_author      | Дата       |
+-----------------+------------------+------------+
| Владивосток     | Достоевский Ф.М. | 2020-12-04 |
| Владивосток     | Лермонтов М.Ю.   | 2020-10-21 |
| Владивосток     | Пастернак Б.Л.   | 2020-08-23 |
| Владивосток     | Есенин С.А.      | 2020-08-14 |
| Владивосток     | Булгаков М.А.    | 2020-01-08 |
| Москва          | Лермонтов М.Ю.   | 2020-09-30 |
| Москва          | Достоевский Ф.М. | 2020-07-21 |
| Москва          | Есенин С.А.      | 2020-06-23 |
| Москва          | Булгаков М.А.    | 2020-05-28 |
| Москва          | Пастернак Б.Л.   | 2020-04-08 |
| Санкт-Петербург | Булгаков М.А.    | 2020-11-05 |
| Санкт-Петербург | Лермонтов М.Ю.   | 2020-10-22 |
| Санкт-Петербург | Достоевский Ф.М. | 2020-09-19 |
| Санкт-Петербург | Есенин С.А.      | 2020-08-11 |
| Санкт-Петербург | Пастернак Б.Л.   | 2020-06-28 |
+-----------------+------------------+------------+
 */
# CREATE TABLE city
#     (
#         city_id INT
#             PRIMARY KEY AUTO_INCREMENT,
#         name_city VARCHAR(30)
#     );


SELECT name_city, name_author, (DATE_ADD('2020-01-01', INTERVAL RAND() * 365 DAY)) AS дата
  FROM city,
       author
 ORDER BY name_city, дата DESC;

/*
Запросы на выборку из нескольких таблиц

Запрос на выборку может выбирать данные из двух и более таблиц базы данных.
При этом таблицы должны быть логически связаны между собой.
Для каждой пары таблиц, включаемых в запрос, необходимо указать свой оператор соединения.
Наиболее распространенным является внутреннее соединение INNER JOIN, поэтому в примерах будем использовать его.

Пусть таблицы связаны между собой следующим образом:
тогда запрос на выборку для этих таблиц будет иметь вид:

SELECT
 ...
FROM
    first
    INNER JOIN  second ON first.first_id = second.first_id
    INNER JOIN  third  ON second.second_id = third.second_id
...

Если же таблицы связаны так:
то запрос на выборку выглядит следующим образом:

SELECT
 ...
FROM
    first
    INNER JOIN  third ON first.first_id = third.first_id
    INNER JOIN second ON third.second_id = second.second_id
...

В этом случае рекомендуется соединение таблиц записывать последовательно, «по кругу»: first → third → second

Вывести информацию о тех книгах, их авторах и жанрах, цена которых принадлежит интервалу
от 500  до 700 рублей включительно.
+-----------------------+----------------+------------+--------+--------+
| title                 | name_author    | name_genre | price  | amount |
+-----------------------+----------------+------------+--------+--------+
| Мастер и Маргарита    | Булгаков М.А.  | Роман      | 670.99 | 3      |
| Белая гвардия         | Булгаков М.А.  | Роман      | 540.50 | 5      |
| Стихотворения и поэмы | Есенин С.А.    | Поэзия     | 650.00 | 15     |
| Черный человек        | Есенин С.А.    | Поэзия     | 570.20 | 6      |
| Лирика                | Пастернак Б.Л. | Поэзия     | 518.99 | 2      |
+-----------------------+----------------+------------+--------+--------+
 */

SELECT title, name_author, name_genre, price, amount
  FROM author
           INNER JOIN book
           ON author.author_id = book.author_id
           INNER JOIN genre
           ON genre.genre_id = book.genre_id
 WHERE price BETWEEN 300 AND 700;

/*
Вывести информацию о книгах (жанр, книга, автор), относящихся к жанру,
включающему слово «роман» в отсортированном по названиям книг виде.

Результат

+------------+--------------------+------------------+
| name_genre | title              | name_author      |
+------------+--------------------+------------------+
| Роман      | Белая гвардия      | Булгаков М.А.    |
| Роман      | Братья Карамазовы  | Достоевский Ф.М. |
| Роман      | Игрок              | Достоевский Ф.М. |
| Роман      | Идиот              | Достоевский Ф.М. |
| Роман      | Мастер и Маргарита | Булгаков М.А.    |
+------------+--------------------+------------------+
 */

SELECT name_genre, title, name_author
  FROM genre g
           JOIN book b
           ON g.genre_id = b.genre_id AND g.name_genre = 'Роман'
           JOIN author
           USING (author_id)
 ORDER BY title;

/*
 Запросы для нескольких таблиц с группировкой

В запросах с групповыми функциями могут использоваться несколько таблиц, между которыми
 используются различные типы соединений.

Пример
Вывести количество различных книг каждого автора.
Информацию отсортировать в алфавитном порядке по фамилиям  авторов.
*/
SELECT name_author, COUNT(title) AS количество
  FROM author
           INNER JOIN book
           ON author.author_id = book.author_id
 GROUP BY name_author
 ORDER BY name_author;

/*
Результат

+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Булгаков М.А.    | 2          |
| Достоевский Ф.М. | 3          |
| Есенин С.А.      | 2          |
| Пастернак Б.Л.   | 1          |
+------------------+------------+

При использовании соединения INNER JOIN мы не можем узнать, что книг Лермонтова на складе нет,
но предполагается, что они могут быть.
Чтобы автор Лермонтов был включен в результат, нужно изменить соединение таблиц.
*/


SELECT name_author, COUNT(title) AS количество
  FROM author a
           LEFT JOIN book b
           ON a.author_id = b.author_id
 GROUP BY name_author
 ORDER BY name_author;

/*
+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Булгаков М.А.    | 2          |
| Достоевский Ф.М. | 3          |
| Есенин С.А.      | 2          |
| Лермонтов М.Ю.   | 0          |
| Пастернак Б.Л.   | 1          |
+------------------+------------+
*/

/*
Посчитать количество экземпляров  книг каждого автора из таблицы author.
Вывести тех авторов, количество книг которых меньше 10, в отсортированном
по возрастанию количества виде.
Последний столбец назвать Количество.

Результат
+----------------+------------+
| name_author    | Количество |
+----------------+------------+
| Лермонтов М.Ю. | NULL       |
| Пастернак Б.Л. | 2          |
| Булгаков М.А.  | 8          |
+----------------+------------+
 */

SELECT name_author, SUM(amount) AS количество
  FROM author a
           LEFT JOIN book b
           ON a.author_id = b.author_id
 GROUP BY name_author
HAVING количество < 10
    OR количество IS NULL
 ORDER BY количество;

/*
Запросы для нескольких таблиц со вложенными запросами
В запросах, построенных на нескольких таблицах, можно использовать вложенные запросы.
Вложенный запрос может быть включен:
после ключевого слова SELECT,  после FROM и в условие отбора после WHERE (HAVING).

Пример
Вывести авторов, общее количество книг которых на складе максимально.
Это достаточно сложный запрос, поэтому будем решать его по шагам (реализуя каждый запрос по отдельности),
а потом объединим все запросы в один.

Шаг 1. Найдем суммарное количество книг на складе по каждому автору.
Поскольку фамилии автора в этой таблице нет, то группировку будем осуществлять по author_id.
 */

SELECT
    author_id,
    SUM(amount) AS sum_amount
FROM
    book
GROUP BY
    author_id;

/*
Результат:

+-----------+------------+
| author_id | sum_amount |
+-----------+------------+
| 1         | 8          |
| 2         | 23         |
| 3         | 21         |
| 4         | 2          |
+-----------+------------+

Шаг 2. В результирующей таблице предыдущего запроса необходимо найти максимальное значение, то есть 23.
Для этого запросу, созданному на шаге 1, необходимо присвоить имя (например, query_in) и использовать
его в качестве таблицы-источника после FROM. Затем уже находить максимум по столбцу sum_amount.
 */


SELECT
    MAX(sum_amount) AS max_sum_amount
FROM
    (
     SELECT
         author_id,
         SUM(amount) AS sum_amount
     FROM
         book
     GROUP BY
         author_id
    ) query_in;

/*
Результат:
+----------------+
| max_sum_amount |
+----------------+
| 23             |
+----------------+

Шаг 3. Выведем фамилию автора и общее количество книг для него.

Запрос:
*/

SELECT name_author, SUM(amount) as Количество
FROM
    author JOIN book
    on author.author_id = book.author_id
GROUP BY name_author;

/*
Результат:
+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Булгаков М.А.    | 8          |
| Достоевский Ф.М. | 23         |
| Есенин С.А.      | 21         |
| Пастернак Б.Л.   | 2          |
+------------------+------------+

Шаг 4.
Включим запрос с шага 2 в условие отбора запроса с шага 3.
И получим всех авторов, общее количество книг которых максимально.
*/

SELECT name_author, SUM(amount) as Количество
FROM
    author JOIN book
    on author.author_id = book.author_id
GROUP BY
    name_author
HAVING SUM(amount) =
     (/* вычисляем максимальное из общего количества книг каждого автора */
      SELECT MAX(sum_amount) AS max_sum_amount
       FROM (/* считаем количество книг каждого автора */
             SELECT author_id, SUM(amount) AS sum_amount FROM book GROUP BY author_id) query_in);
/*
Результат:
+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Достоевский Ф.М. | 23         |
+------------------+------------+
 */

/*
 Вывести в алфавитном порядке всех авторов, которые пишут только в одном жанре.
 Поскольку у нас в таблицах так занесены данные, что у каждого автора книги только в одном жанре,
 для этого запроса внесем изменения в таблицу book.
 Пусть у нас  книга Есенина «Черный человек» относится к жанру «Роман»,
 а книга Булгакова «Белая гвардия» к «Приключениям»
 (эти изменения в таблицы уже внесены).
 +------------------+
| name_author      |
+------------------+
| Достоевский Ф.М. |
| Пастернак Б.Л.   |
+------------------+
 */

SELECT
    name_author
FROM
    author
    LEFT JOIN book ON author.author_id=book.author_id
    LEFT JOIN genre ON genre.genre_id=book.genre_id
GROUP BY
    name_author
HAVING
    COUNT(DISTINCT(name_genre)) = 1
ORDER BY
    name_author;

SELECT name_author
FROM author a
WHERE exists (SELECT author_id
                FROM book b
                WHERE a.author_id = b.author_id
                GROUP BY author_id
                HAVING COUNT(DISTINCT genre_id) = 1)


# Вывести информацию о книгах (название книги, фамилию и инициалы автора, название жанра, цену и количество
# экземпляров книг), написанных в самых популярных жанрах, в отсортированном в алфавитном порядке по названию книг виде.

# Самым популярным считать жанр, общее количество экземпляров книг которого на складе максимально.
#
# Результат
#
# +-----------------------+------------------+------------+--------+--------+
# | title                 | name_author      | name_genre | price  | amount |
# +-----------------------+------------------+------------+--------+--------+
# | Белая гвардия         | Булгаков М.А.    | Роман      | 540.50 | 5      |
# | Братья Карамазовы     | Достоевский Ф.М. | Роман      | 799.01 | 3      |
# | Игрок                 | Достоевский Ф.М. | Роман      | 480.50 | 10     |
# | Идиот                 | Достоевский Ф.М. | Роман      | 460.00 | 10     |
# | Лирика                | Пастернак Б.Л.   | Поэзия     | 518.99 | 10     |
# | Мастер и Маргарита    | Булгаков М.А.    | Роман      | 670.99 | 3      |
# | Стихотворения и поэмы | Есенин С.А.      | Поэзия     | 650.00 | 15     |
# | Черный человек        | Есенин С.А.      | Поэзия     | 570.20 | 6      |
# +-----------------------+------------------+------------+--------+--------+
#

SELECT title, name_author, name_genre, price, amount
FROM book
    # INNER JOIN genre ON genre.genre_id=book.genre_id
    # INNER JOIN author ON author.author_id=book.author_id
    JOIN author USING(author_id)
    JOIN genre USING(genre_id)
WHERE
    book.genre_id IN (
    SELECT query_in_1.genre_id
    FROM
    (/*получаем коды жанра и количество произведений*/
    SELECT genre_id, SUM(amount) AS sum_amount
    FROM book
    GROUP BY genre_id
    ) query_in_1
    INNER JOIN
    (/*получаем максимальное число книг в жанре*/
    SELECT genre_id, SUM(amount) AS sum_amount
    FROM book
    GROUP BY genre_id
    ORDER BY sum_amount DESC
    LIMIT 1
    ) query_in_2
    ON query_in_1.sum_amount = query_in_2.sum_amount
    )
ORDER BY title;



# Если в таблицах supply  и book есть одинаковые книги, которые имеют равную цену,
# вывести их название и автора, а также посчитать общее количество экземпляров книг
# в таблицах supply и book, столбцы назвать Название, Автор  и Количество.
#
# Результат
#
# +----------------+-------------+------------+
# | Название       | Автор       | Количество |
# +----------------+-------------+------------+
# | Черный человек | Есенин С.А. | 12         |
# +----------------+-------------+------------+

CREATE TABLE supply
    (
        supply_id INT PRIMARY KEY AUTO_INCREMENT,
        title VARCHAR(50),
        author VARCHAR(30),
        price DECIMAL(8, 2),
        amount INT
    );


INSERT INTO
    supply (title, author, price, amount)
VALUES
    ('Доктор Живаго', 'Пастернак Б.Л.', 618.99, 3),
    ('Черный человек', 'Есенин С.А.', 570.20, 6),
    ('Евгений Онегин', 'Пушкин А.С.', 440.80, 5),
    ('Идиот', 'Достоевский Ф.М.', 360.80, 3);

SELECT
    b.title AS Название,
    name_author AS Автор,
    b.amount + s.amount AS Количество
FROM
    book b
JOIN author a USING (author_id)
JOIN supply s ON (b.title , a.name_author, b.price) = (s.title, s.author, s.price);


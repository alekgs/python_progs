# Отобрать все шаги, в которых рассматриваются вложенные запросы (то есть в названии шага упоминаются вложенные
# запросы). Указать к какому уроку и модулю они относятся.

# Для этого вывести 3 поля:
#    в поле Модуль указать номер модуля и его название через пробел;
#    в поле Урок указать номер модуля, порядковый номер урока (lesson_position) через точку и название урока через
#    пробел;
#    в поле Шаг указать номер модуля, порядковый номер урока (lesson_position) через точку, порядковый номер шага
#    (step_position) через точку и название шага через пробел.

# Длину полей Модуль и Урок ограничить 19 символами, при этом слишком длинные надписи обозначить многоточием в конце
# (16 символов - это номер модуля или урока, пробел и  название Урока или Модуля к ним присоединить '...').
# Информацию отсортировать по возрастанию номеров модулей, порядковых номеров уроков и порядковых номеров шагов.

# +---------------------+---------------------+-------------------------------------------------------------+
# | Модуль              | Урок                | Шаг                                                         |
# +---------------------+---------------------+-------------------------------------------------------------+
# | 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.2 Вложенный запрос, возвращающий одно значение          |
# | 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.3 Использование вложенного запроса в выражении          |
# | 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.4 Вложенный запрос, оператор IN                         |
# | 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.5 Вложенный запрос, операторы ANY и ALL                 |
# | 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.6 Вложенный запрос после SELECT                         |
# | 1 Основы реляцио... | 1.5 Запросы корр... | 1.5.5 Добавление записей, вложенные запросы                 |
# | 2 Запросы SQL к ... | 2.2 Запросы на в... | 2.2.7 Запросы для нескольких таблиц со вложенными запросами |
# | 2 Запросы SQL к ... | 2.2 Запросы на в... | 2.2.8 Вложенные запросы в операторах соединения             |
# | 2 Запросы SQL к ... | 2.3 Запросы корр... | 2.3.5 Запрос на обновление, вложенные запросы               |
# +---------------------+---------------------+-------------------------------------------------------------+

SELECT
    CONCAT(LEFT(CONCAT(module_id, ' ',module_name), 16), '...') as Модуль,
    CONCAT(LEFT(CONCAT(module_id, '.', lesson_position, ' ', lesson_name), 16), '...') as Урок,
    CONCAT(module_id, '.', lesson_position, '.', step_position, ' ',step_name) as Шаг
FROM
    module m
    JOIN lesson l USING(module_id)
    JOIN step s ON
         l.lesson_id = s.lesson_id AND
         s.step_name LIKE '%ложенн% запрос%'
ORDER BY
    Модуль, Урок, Шаг;



# Еще одна возможность улучшить навигацию по курсу - это реализация поиска шагов по ключевым словам.
# Для этого необходимо создать таблицу с терминами keyword, а затем связать ее с таблицей step через вспомогательную
# таблицу step_keyword. Каждая запись этой таблицы - это id шага и id встречающегося на этом шаге ключевого слова.

# Задание
# Заполнить таблицу step_keyword следующим образом: если ключевое слово есть в названии шага, то включить в
# step_keyword строку с id шага и id ключевого слова.

# Пояснение
# 1. Чтобы проверить, есть ли ключевое слово в заголовке шага, можно использовать функцию:
# INSTR(string_1, string_2)
# которая возвращает позицию первого вхождения string_2 в string_1. Если вхождения нет - результат функции 0.

# 2. Обратите внимание, что некоторые ключевые слова, например IN, входят в INNER и JOIN. Нужно учитывать только
# отдельные слова, которые разделены в названии шага либо пробелом, либо запятой, либо открывающей скобкой.

# 3. Это задание можно решить с помощью регулярных выражений (комментарий  Алексея Карелина) или с помощью функции
# REGEXP_INSTR (комментарий Yury Popov).

# Примечание:
# это не таблица step_keyword , а запрос, который показывает результат на основе 3-х таблиц,
# чтобы визуально проверить, правильно ли сформирована таблица.

# Query result:
# +--------------------------------------------------------------+--------------+
# | step_name                                                    | keyword_name |
# +--------------------------------------------------------------+--------------+
# | Вложенный запрос после SELECT                                | SELECT       |
# | Соединение INNER JOIN                                        | INNER        |
# | Внешнее соединение LEFT и RIGHT OUTER JOIN                   | LEFT         |
# | Внешнее соединение LEFT и RIGHT OUTER JOIN                   | RIGHT        |
# | Внешнее соединение LEFT и RIGHT OUTER JOIN                   | OUTER        |
# | Соединение INNER JOIN                                        | JOIN         |
# | Внешнее соединение LEFT и RIGHT OUTER JOIN                   | JOIN         |
# | Перекрестное соединение CROSS JOIN                           | JOIN         |
# | Перекрестное соединение CROSS JOIN                           | CROSS        |
# | Выборка данных по условию, групповые функции, WHERE и HAVING | WHERE        |
# | Выборка данных по условию, групповые функции, WHERE и HAVING | HAVING       |
# | Выборка данных, групповые функции SUM и COUNT                | SUM          |
# | Выборка данных, групповые функции MIN, MAX и AVG             | AVG          |
# | Выборка данных c вычислением, групповые функции, AVG         | AVG          |
# | Выборка данных, групповые функции SUM и COUNT                | COUNT        |
# | Выборка данных, групповые функции MIN, MAX и AVG             | MIN          |
# | Выборка данных по условию, групповые функции, MIN            | MIN          |
# | Выборка данных, групповые функции MIN, MAX и AVG             | MAX          |
# | Операция соединение, использование USING()                   | USING        |
# | Задание. Работа с архивной таблицей, оператор UNION, часть 1 | UNION        |
# | Задание. Работа с архивной таблицей, оператор UNION, часть 2 | UNION        |
# | Вложенный запрос, операторы ANY и ALL                        | ALL          |
# | Вложенный запрос, операторы ANY и ALL                        | ANY          |
# | Выборка данных, операторы BETWEEN, IN                        | IN           |
# | Вложенный запрос, оператор IN                                | IN           |
# | Выборка данных, оператор LIKE                                | LIKE         |
# | Выборка данных, операторы BETWEEN, IN                        | BETWEEN      |
# +--------------------------------------------------------------+--------------+
#
# В результате выполнения запроса таблица step_keyword  имеет вид:
#
# Affected rows: 27
#
# Query result:
# +---------+------------+
# | step_id | keyword_id |
# +---------+------------+
# | 38      | 1          |
# | 81      | 3          |
# | 82      | 4          |
# | 82      | 5          |
# | 82      | 6          |
# | 81      | 7          |
# | 82      | 7          |
# | 83      | 7          |
# | 83      | 8          |
# | 47      | 10         |
# | 47      | 11         |
# | 42      | 15         |
# | 43      | 16         |
# | 44      | 16         |
# | 42      | 17         |
# | 43      | 18         |
# | 46      | 18         |
# | 43      | 19         |
# | 88      | 26         |
# | 112     | 27         |
# | 113     | 27         |
# | 37      | 28         |
# | 37      | 29         |
# | 18      | 30         |
# | 36      | 30         |
# | 19      | 31         |
# | 18      | 32         |
# +---------+------------+

INSERT INTO
    step_keyword
    (step_id, keyword_id)
SELECT
    step_id,
    keyword_id
FROM
    step
     JOIN keyword ON
        REGEXP_INSTR(step_name, CONCAT('\\b', keyword_name, '\\b'))
ORDER BY
    keyword_id;




# Реализовать поиск по ключевым словам. Вывести шаги, с которыми связаны ключевые слова MAX и AVG одновременно.
# Для шагов указать id модуля, позицию урока в модуле, позицию шага в уроке через точку, после позиции шага перед
# заголовком - пробел. Позицию шага в уроке вывести в виде двух цифр (если позиция шага меньше 10, то перед цифрой
# поставить 0). Столбец назвать Шаг. Информацию отсортировать по первому столбцу в алфавитном порядке.

# Результат
#
# +---------------------------------------------------------+
# | Шаг                                                     |
# +---------------------------------------------------------+
# | 1.3.04 Выборка данных, групповые функции MIN, MAX и AVG |
# | 1.4.06 Вложенный запрос после SELECT                    |
# +---------------------------------------------------------+

SELECT
    CONCAT(
           module_id, '.', lesson_position,
              IF
                (
                 step_position < 10, CONCAT('.0', step_position), CONCAT('.', step_position)),
                 ' ', step_name
                 ) AS Шаг
  FROM
      step_keyword
      JOIN step USING (step_id)
      JOIN lesson USING (lesson_id)
      JOIN module USING (module_id)
      JOIN keyword USING (keyword_id)
 WHERE
     REGEXP_INSTR(keyword_name, CONCAT('\\b','(MAX)|(AVG)','\\b'))
 GROUP BY
     Шаг HAVING COUNT(keyword_name) = 2
 ORDER BY Шаг;


# Отнести каждого студента к группе,  в зависимости от пройденных заданий:
# Интервал 	Группа
# от 0 до 10 	I
# от 11 до 15 	II
# от 16 до 27 	III
# больше 27 	IV

# Пройденными считаются задания с хотя бы одним верным ответом. В таблице step_student сохраняются все попытки
# пользователей, следовательно, могут быть пользователи, у которых на одно задание есть несколько верных попыток.

SELECT student_name, rate, 
    CASE
        WHEN rate <= 10 THEN 'I'
        WHEN rate <= 15 THEN 'II'
        WHEN rate <= 27 THEN 'III'
        ELSE 'IV'
    END AS Группа
FROM      
    (
     SELECT student_name, count(*) as rate
     FROM 
         (
          SELECT student_name, step_id
          FROM 
              student 
              INNER JOIN step_student USING(student_id)
          WHERE result = 'correct'
          GROUP BY student_name, step_id
         ) query_in
     GROUP BY student_name 
     ORDER BY 2
    ) query_in_1;

# Посчитать, сколько студентов относится к каждой группе. Столбцы назвать Группа, Интервал, Количество.
# Указать границы интервала.

# Это задание можно решить и другим способом (без  CASE).
# Для этого можно создать таблицу с интервалами и использовать ее в запросе.

# Связанные шаги
#     выборка столбцов и их именование;
#     соединение таблиц;
#     вложенные запросы в операторах соединения;
#     условие отбора;
#     вычисления для сгруппированных данных;
#     сортировка.
#
# Результат
#
# +--------+-------------+------------+
# | Группа | Интервал    | Количество |
# +--------+-------------+------------+
# | I      | от 0 до 10  | 10         |
# | II     | от 11 до 15 | 27         |
# | III    | от 16 до 27 | 9          |
# | IV     | больше 27   | 18         |
# +--------+-------------+------------+

SELECT
    CASE
        WHEN rate <= 10 THEN 'I'
        WHEN rate <= 15 THEN 'II'
        WHEN rate <= 27 THEN 'III'
        ELSE 'IV'
    END AS Группа,
    CASE
        WHEN rate <= 10 THEN 'от 0 до 10'
        WHEN rate <= 15 THEN 'от 11 до 15'
        WHEN rate <= 27 THEN 'от 16 до 27'
        ELSE 'больше 27'
    END AS Интервал,
    COUNT(student_name) AS Количество
FROM
    (
     SELECT student_name, count(*) AS rate
     FROM
         (
          SELECT student_name, step_id
          FROM
              student
              INNER JOIN step_student USING(student_id)
          WHERE result = 'correct'
          GROUP BY student_name, step_id
         ) query_in
     GROUP BY student_name
     ORDER BY 2
    ) query_in_1
GROUP BY
    Группа, Интервал;

# Для каждого шага вывести процент правильных решений. Информацию упорядочить по возрастанию процента верных решений.
# Столбцы результата назвать Шаг и Успешность, процент успешных решений округлить до целого.
# Важно. Только для этого задания для одного из шагов установлено, что все ответы пользователей - неверные.

WITH get_count_correct (st_n_c, count_correct) 
  AS (
    SELECT step_name, count(*)
    FROM 
        step 
        INNER JOIN step_student USING (step_id)
    WHERE result = 'correct'
    GROUP BY step_name
   ),
  get_count_wrong (st_n_w, count_wrong) 
  AS (
    SELECT step_name, count(*)
    FROM 
        step 
        INNER JOIN step_student USING (step_id)
    WHERE result = 'wrong'
    GROUP BY step_name
   )  
SELECT st_n_c AS Шаг,
    ROUND(count_correct / (count_correct + count_wrong) * 100) AS Успешность
FROM  
    get_count_correct 
    LEFT JOIN get_count_wrong ON st_n_c = st_n_w
UNION
SELECT st_n_w AS Шаг,
    ROUND(count_correct / (count_correct + count_wrong) * 100) AS Успешность
FROM  
    get_count_correct 
    RIGHT JOIN get_count_wrong ON st_n_c = st_n_w
ORDER BY 2;

# Исправить запрос примера так: для шагов, которые  не имеют неверных ответов,  указать 100 как процент успешных
#  попыток, если же шаг не имеет верных ответов, указать 0.

#  Информацию отсортировать сначала по возрастанию  успешности, а затем по названию шага в алфавитном порядке.

#Результат
# +--------------------------------------------------------------------------+------------+
# | Шаг                                                                      | Успешность |
# +--------------------------------------------------------------------------+------------+
# | Задание. Работа с архивной таблицей, оператор UNION, часть 1             | 0          |
# | Выборка данных, оператор LIKE                                            | 19         |
# | Вложенные запросы в операторах соединения                                | 32         |
#                      ....
# | Выборка отдельных столбцов и присвоение им новых имен                    | 84         |
# | Выборка всех данных из таблицы                                           | 87         |
# | Задание. Работа с архивной таблицей, оператор UNION, часть 2             | 100        |
# | Построение логической схемы базы данных                                  | 100        |
# +--------------------------------------------------------------------------+------------+
# Affected rows: 32

WITH get_count_correct (st_n_c, count_correct)
  AS (
    SELECT step_name, count(*)
    FROM
        step
        INNER JOIN step_student USING (step_id)
    WHERE result = 'correct'
    GROUP BY step_name
   ),
  get_count_wrong (st_n_w, count_wrong)
  AS (
    SELECT step_name, count(*)
    FROM
        step
        INNER JOIN step_student USING (step_id)
    WHERE result = 'wrong'
    GROUP BY step_name
   )
SELECT st_n_c AS Шаг,
    CASE
        WHEN count_wrong IS NULL THEN 100
        WHEN count_correct IS NULL THEN 0
        ELSE
            ROUND(count_correct / (count_correct + count_wrong) * 100)
    END AS Успешность
FROM
    get_count_correct
    LEFT JOIN get_count_wrong ON st_n_c = st_n_w

UNION

SELECT st_n_w AS Шаг,
    CASE
        WHEN count_wrong IS NULL THEN 100
        WHEN count_correct IS NULL THEN 0
        ELSE
            ROUND(count_correct / (count_correct + count_wrong) * 100)
    END AS Успешность
FROM
    get_count_correct
    RIGHT JOIN get_count_wrong ON st_n_c = st_n_w
ORDER BY 2, 1;


# 2
SELECT step_name AS Шаг,
       ROUND(SUM(success)/COUNT(*)*100,0) AS Успешность
FROM (
      SELECT
        step_name,
        IF(result = 'correct',1,0) AS success
      FROM step
          JOIN step_student USING (step_id)
     ) AS q_in
GROUP BY
    step_name
ORDER BY
    2,1;



# Вычислить прогресс пользователей по курсу. Прогресс вычисляется как отношение верно пройденных шагов к общему
# количеству шагов в процентах, округленное до целого. В нашей базе данные о решениях занесены не для всех шагов,
# поэтому общее количество шагов определить как количество различных шагов в таблице step_student.

# Тем пользователям, которые прошли все шаги (прогресс = 100%) выдать 'Сертификат с отличием'.
# Тем, у кого прогресс больше или равен 80% -  'Сертификат'.
# Для остальных записей в столбце Результат задать пустую строку ('').

# Информацию отсортировать по убыванию прогресса, затем по имени пользователя в алфавитном порядке.

# Результат
# +------------+----------+-----------------------+
# | Студент    | Прогресс | Результат             |
# +------------+----------+-----------------------+
# | student_60 | 100      | Сертификат с отличием |
# | student_15 | 94       | Сертификат            |
# | student_18 | 94       | Сертификат            |
#                  ...
# | student_29 | 25       |                       |
# | student_47 | 25       |                       |
# +------------+----------+-----------------------+
# Affected rows: 64

###### 1
SET @max = (SELECT COUNT(DISTINCT step_id) FROM step_student);
WITH table_result #(name, result_student)
   AS (
        SELECT
            student_name,
            ROUND(COUNT(DISTINCT step_id) / @max * 100) AS result
        FROM
            student s
            JOIN step_student ss ON
                 s.student_id = ss.student_id AND
                 ss.result ='correct'
        GROUP BY
            student_name
        ORDER BY 2 DESC
      )

SELECT
    student_name AS Студент,
    result AS Прогресс,
    CASE
        WHEN result < 80 THEN ''
        WHEN result BETWEEN 80 AND 99 THEN 'Сертификат'
        ELSE 'Сертификат с отличием'
    END AS Результат
FROM
    table_result
ORDER BY 2 DESC, 1;

##### 2
SET @max = (SELECT COUNT(DISTINCT step_id) FROM step_student);
SELECT
    student_name AS Студент,
    ROUND(COUNT(DISTINCT step_id) / @max * 100) AS Прогресс,
    CASE
        WHEN ROUND(COUNT(DISTINCT step_id) / @max * 100) < 80 THEN ''
        WHEN ROUND(COUNT(DISTINCT step_id) / @max * 100) BETWEEN 80 AND 99 THEN 'Сертификат'
        ELSE 'Сертификат с отличием'
    END AS Результат
FROM
    student s
    JOIN step_student ss ON
         s.student_id = ss.student_id AND
         ss.result ='correct'
GROUP BY
     student_name
ORDER BY 2 DESC, 1;


# Вычислить, сколько шагов прошел пользователь.
# Ранжировать пользователей по убыванию результатов.

SELECT
    ROW_NUMBER() OVER (ORDER BY count(DISTINCT step_id) DESC) AS №,
    student_name,
    COUNT(DISTINCT step_id) AS Kоличество,
    RANK() OVER (ORDER BY count(DISTINCT step_id) DESC) AS Ранг
FROM
    student s
    JOIN step_student ss ON
         s.student_id = ss.student_id AND
         ss.result ='correct'
WHERE
    result = 'correct'
GROUP BY
    student_name;

# Дополнительно ранжируем студентов.

SELECT
    ROW_NUMBER() OVER (ORDER BY  count(DISTINCT step_id) DESC) AS Номер_пп,
    student_name,
    count(DISTINCT step_id) AS Kоличество,
    RANK() OVER (ORDER BY count(DISTINCT step_id) DESC) AS Ранг,
    DENSE_RANK() OVER (ORDER BY count(DISTINCT step_id) DESC) AS Рейтинг
FROM
    student
    JOIN step_student USING (student_id)
WHERE
    result = 'correct'
GROUP BY
    student_name;

# Для каждого студента указать, на сколько меньше он прошел шагов, чем идущий перед ним по рейтингу студент.
SELECT
    student_name,
    count(DISTINCT step_id) AS Количество,
    IFNULL(LAG(count(DISTINCT step_id))
        OVER
         (
          ORDER BY count(DISTINCT step_id) DESC) - count(DISTINCT step_id),0
         )
    AS Разница
FROM
    student
    JOIN step_student USING (student_id)
WHERE
    result = 'correct'
GROUP BY
    student_name;



# Для студента с именем student_61 вывести все его попытки: название шага, результат
# и дату отправки попытки (submission_time).
# Информацию отсортировать по дате отправки попытки и указать, сколько минут прошло между отправкой соседних попыток.

# Название шага ограничить 20 символами и добавить '...'.
# Столбцы назвать Студент, Шаг, Результат, Дата_отправки, Разница

# Результат
#
# +------------+-------------------------+-----------+---------------------+------------------+
# | Студент    | Шаг                     | Результат | Дата_отправки       | Разница          |
# +------------+-------------------------+-----------+---------------------+------------------+
# | student_61 | Выборка всех данных ... | correct   | 2020-08-27 14:22:14 | 0:00:00          |
# | student_61 | Выборка отдельных ст... | correct   | 2020-08-27 14:23:53 | 0:01:39          |
# | student_61 | Выборка отдельных ст... | correct   | 2020-08-27 14:28:41 | 0:04:48          |
# | student_61 | Выборка данных с соз... | wrong     | 2020-08-27 14:33:57 | 0:05:16          |
# | student_61 | Выборка данных с соз... | wrong     | 2020-08-27 14:34:24 | 0:00:27          |
#                                         ...
# | student_61 | Выборка данных с сор... | correct   | 2020-08-27 16:14:15 | 0:01:24          |
# | student_61 | Соединение INNER JOI... | correct   | 2020-09-01 07:25:39 | 4 days, 15:11:24 |
# | student_61 | Внешнее соединение L... | wrong     | 2020-09-01 09:53:30 | 2:27:51          |
# | student_61 | Внешнее соединение L... | correct   | 2020-09-01 09:53:50 | 0:00:20          |
# | student_61 | Перекрестное соедине... | wrong     | 2020-09-01 10:45:30 | 0:51:40          |
# | student_61 | Перекрестное соедине... | wrong     | 2020-09-01 10:46:21 | 0:00:51          |
# | student_61 | Перекрестное соедине... | correct   | 2020-09-01 10:47:55 | 0:01:34          |
# +------------+-------------------------+-----------+---------------------+------------------+

# Пояснение
# # 1. Время в таблице step_student представлено в формате  Unix-время , в котором хранится количество секунд, прошедших
# # с 1 января 1970 года. Для перевода к привычному виду DATE используется формула:
# 1970-01-01 + time_unix / 86400
# В SQL для перевода удобно использовать функцию  FROM_UNIXTIME( ).
# Например:
# FROM_UNIXTIME(1598291490) =  2020-08-24 17:51:30
# 2. Для перевода количества секунд во временной формат используется функция SEC_TO_TIME(),например:
# SEC_TO_TIME(288) = 0:04:48

# Вместо проверки IFNULL можно использовать необязательные параметры функции:
# LAG(столбец, количество-строк, выражение-если-null), где
# 'количество-строк' - по умолчанию = 1 (если не указываем, то значение из предыдущей строки, но можем указать любой
# сдвиг), 'выражение-если-null' - по умолчанию null, но можем указать любое, которое и будет использовано в
# дальнейших вычислениях. Применительно к этой задаче указывать надо не 0, а то же самое значение (само себя), тогда
# получится:
# Дата_отправки - Дата_отправки = 0.

SELECT student_name AS Студент,
       CONCAT(LEFT(step_name,20),'...') AS Шаг,
       result AS Результат,
       FROM_UNIXTIME(submission_time) AS Дата_отправки,
       # SEC_TO_TIME(IFNULL(submission_time - LAG(submission_time) OVER (ORDER BY submission_time),0)) AS Разница
       SEC_TO_TIME(submission_time - LAG(submission_time, 1, submission_time) OVER(ORDER BY submission_time)) AS Разница
FROM
    student
    JOIN step_student USING (student_id)
    JOIN step USING (step_id)
WHERE
    student_name = 'student_61'
GROUP BY
    student_name,
    step_name,
    result,
    submission_time;




# Посчитать среднее время, за которое пользователи проходят урок по следующему алгоритму:

#  - для каждого пользователя вычислить время прохождения шага как сумму времени, потраченного на каждую попытку
#  (время попытки - это разница между временем отправки задания и временем начала попытки), при этом попытки, которые
#  длились # больше 4 часов не учитывать, так как пользователь мог просто оставить задание открытым в браузере,
# а вернуться к  нему на следующий день;

# - для каждого студента посчитать общее время, которое он затратил на каждый урок;

# - вычислить среднее время выполнения урока в часах, результат округлить до 2-х знаков после запятой;

# вывести информацию по возрастанию времени, пронумеровав строки, для каждого урока указать номер модуля и его позицию
# в нем.

#  Столбцы результата назвать Номер, Урок, Среднее_время.

# Результат
# +-------+-------------------------------------------------------------+---------------+
# | Номер | Урок                                                        | Среднее_время |
# +-------+-------------------------------------------------------------+---------------+
# | 1     | 2.2 Запросы на выборку, соединение таблиц                   | 2.37          |
# | 2     | 1.2 Выборка данных                                          | 2.65          |
# | 3     | 2.4 База данных 'Интернет-магазин книг', запросы на выборку | 3.65          |
# +-------+-------------------------------------------------------------+---------------+

with
      q1 AS
      (
        SELECT
               student_id,
               CONCAT(module_id,'.', lesson_position, ' ', lesson_name) as lesson,
               SUM(submission_time - attempt_time) AS lesson_time
        FROM
               step_student
               JOIN step USING (step_id)
               JOIN lesson USING (lesson_id)
               JOIN module USING (module_id)
        WHERE
               submission_time - attempt_time < 14400
        GROUP BY
             student_id,
             lesson
        ),
    q2 (Урок, Среднее_время) AS
        (
         SELECT
             lesson,
             ROUND(AVG(lesson_time / 3600), 2)
         FROM q1
         GROUP BY lesson
        )

SELECT
      ROW_NUMBER() OVER (ORDER BY Среднее_время) AS Номер,
      Урок,
      Среднее_время
FROM q2;



# Вычислить, сколько шагов прошел пользователь по каждому модулю. Ранжировать пользователей по убыванию результатов в
# каждом модуле.

WITH get_rate_lesson(mod_id, stud, rate)
AS
(
   SELECT
       module_id,
       student_name,
       count(DISTINCT step_id)
   FROM student
        JOIN step_student USING(student_id)
        JOIN step USING (step_id)
        JOIN lesson USING (lesson_id)
   WHERE
       result = 'correct'
   GROUP BY
       module_id,
       student_name
)
SELECT
    ROW_NUMBER() OVER (PARTITION BY mod_id ORDER BY rate DESC) AS Номер,
    mod_id AS Модуль,
    stud AS Студент,
    rate AS Количество_шагов,
    RANK() OVER (PARTITION BY mod_id ORDER BY rate DESC) AS Ранг,
    DENSE_RANK() OVER (PARTITION BY mod_id ORDER BY rate DESC) AS Рейтинг
FROM
    get_rate_lesson;

# Результат:
#
# +--------+------------+---------+-------+------+---------+
# | Модуль | Студент    | Рейтинг | Номер | Ранг | Рейтинг |
# +--------+------------+---------+-------+------+---------+
# | 1      | student_1  | 11      | 1     | 1    | 1       |
# | 1      | student_10 | 11      | 2     | 1    | 1       |
# | 1      | student_11 | 11      | 3     | 1    | 1       |
# | 1      | student_12 | 11      | 4     | 1    | 1       |
# | 1      | student_13 | 11      | 5     | 1    | 1       |
#                         ...
# | 1      | student_29 | 8       | 63    | 63   | 4       |
# | 1      | student_47 | 8       | 64    | 63   | 4       |
# | 2      | student_60 | 21      | 1     | 1    | 1       |
# | 2      | student_15 | 19      | 2     | 2    | 2       |
#                         ...
# | 2      | student_56 | 9       | 23    | 22   | 7       |
# | 2      | student_34 | 8       | 24    | 24   | 8       |
# | 2      | student_40 | 8       | 25    | 24   | 8       |
# | 2      | student_11 | 5       | 26    | 26   | 9       |
# | 2      | student_48 | 5       | 27    | 26   | 9       |
# | 2      | student_42 | 4       | 28    | 28   | 10      |
# | 2      | student_61 | 3       | 29    | 29   | 11      |
# | 2      | student_13 | 2       | 30    | 30   | 12      |
# | 2      | student_26 | 2       | 31    | 30   | 12      |
# +--------+------------+---------+-------+------+---------+
# Affected rows: 95

# Как видно из результирующей таблицы, и нумерация, и ранжирование, и рейтинг осуществляется сначала (с 1) для каждого
# модуля.



# Посчитать, сколько шагов пройдено пользователями по каждому уроку.
# Вывести максимальное и минимальное значение пройденных шагов по каждому модулю.

WITH get_rate_lesson (mod_id, les, rate)
AS
(
   SELECT
       module_id,
       CONCAT(module_id,'.', lesson_position),
       count(DISTINCT step_id)
   FROM
       step_student
        JOIN step USING (step_id)
        JOIN lesson USING (lesson_id)
   WHERE
       result = 'correct'
   GROUP BY
       module_id, 2
)

SELECT
    mod_id AS Модуль,
    les AS Урок,
    rate AS Пройдено_шагов,
    MAX(rate) OVER (PARTITION BY mod_id) AS Максимум_по_модулю,
    MIN(rate) OVER (PARTITION BY mod_id) AS Минимум_по_модулю
FROM
    get_rate_lesson;

# Результат:
#
# +--------+------+----------------+--------------------+-------------------+
# | Модуль | Урок | Пройдено_шагов | Максимум_по_модулю | Минимум_по_модулю |
# +--------+------+----------------+--------------------+-------------------+
# | 1      | 1.2  | 11             | 11                 | 11                |
# | 2      | 2.2  | 8              | 13                 | 8                 |
# | 2      | 2.4  | 13             | 13                 | 8                 |
# +--------+------+----------------+--------------------+-------------------+
# Affected rows: 3

# Вычислить рейтинг каждого студента относительно студента, прошедшего наибольшее количество шагов в модуле
# (вычисляется как отношение количества пройденных студентом шагов к максимальному количеству пройденных шагов,
# умноженное на 100).

# Вывести номер модуля, имя студента, количество пройденных им шагов и относительный рейтинг.
# Относительный рейтинг округлить до одного знака после запятой.

# Столбцы назвать Модуль, Студент, Пройдено_шагов и Относительный_рейтинг  соответственно.

# Информацию отсортировать сначала по возрастанию номера модуля, потом по
# убыванию относительного рейтинга и, наконец, по имени студента в алфавитном порядке.

# Связанные шаги
#     выборка столбцов и их именование;
#     соединение таблиц;
#     условие отбора;
#     уникальные записи;
#     групповые функции (шаг, шаг);
#     оконные функции;
#     сортировка.
#
# Результат
#
# +--------+------------+----------------+-----------------------+
# | Модуль | Студент    | Пройдено_шагов | Относительный_рейтинг |
# +--------+------------+----------------+-----------------------+
# | 1      | student_1  | 11             | 100.0                 |
# | 1      | student_10 | 11             | 100.0                 |
# | 1      | student_11 | 11             | 100.0                 |
#                               ...
# | 1      | student_47 | 8              | 72.7                  |
# | 2      | student_60 | 21             | 100.0                 |
# | 2      | student_15 | 19             | 90.5                  |
# | 2      | student_18 | 19             | 90.5                  |
# | 2      | student_27 | 19             | 90.5                  |
# | 2      | student_30 | 19             | 90.5                  |
# | 2      | student_31 | 19             | 90.5                  |
# | 2      | student_36 | 19             | 90.5                  |
# | 2      | student_39 | 19             | 90.5                  |
# | 2      | student_4  | 19             | 90.5                  |
# | 2      | student_43 | 19             | 90.5                  |
# | 2      | student_44 | 19             | 90.5                  |
# | 2      | student_46 | 19             | 90.5                  |
# | 2      | student_49 | 19             | 90.5                  |
#                                ...
# | 2      | student_48 | 5              | 23.8                  |
# | 2      | student_42 | 4              | 19.0                  |
# | 2      | student_61 | 3              | 14.3                  |
# | 2      | student_13 | 2              | 9.5                   |
# | 2      | student_26 | 2              | 9.5                   |
# +--------+------------+----------------+-----------------------+
# Affected rows: 95
WITH
    get_steps (module_id, student, steps) AS
(
SELECT
    module_id,
    student_name,
    COUNT(DISTINCT step_id)
  FROM step_student
        JOIN student USING (student_id)
        JOIN step USING (step_id)
        JOIN lesson USING (lesson_id)
        JOIN module USING (module_id)
 WHERE
     result = 'correct'
 GROUP BY
     module_id,
     student_name
)

SELECT
    module_id AS Модуль,
    student   AS Студент,
    steps     AS Пройдено_шагов,
    ROUND(steps * 100/ MAX(steps)
      OVER (PARTITION BY module_id), 1)
             AS Относительный_рейтинг
FROM
    get_steps
ORDER BY
    1, 4 DESC, 2;


# Проанализировать, в каком порядке и с каким интервалом пользователь отправлял последнее верно выполненное задание
# каждого урока. В базе занесены попытки студентов  для трех уроков курса, поэтому анализ проводить только для этих
# уроков.

# Для студентов прошедших как минимум по одному шагу в каждом уроке, найти последний пройденный шаг каждого урока -
# крайний шаг, и указать:
#     имя студента;
#     номер урока, состоящий из номера модуля и через точку позиции каждого урока в модуле;
#     время отправки  - время подачи решения на проверку;
#     разницу во времени отправки между текущим и предыдущим крайним шагом в днях, при этом для первого шага
#     поставить прочерк ('-'), а количество дней округлить до целого в большую сторону.
#
# Столбцы назвать  Студент, Урок,  Макс_время_отправки и Интервал  соответственно. Отсортировать результаты по имени
# студента в алфавитном порядке, а потом по возрастанию времени отправки.

# +------------+------+---------------------+----------+
# | Студент    | Урок | Макс_время_отправки | Интервал |
# +------------+------+---------------------+----------+
# | student_15 | 1.2  | 2020-05-20 12:35:57 | -        |
# | student_15 | 2.4  | 2020-06-08 07:10:24 | 19       |
# | student_15 | 2.2  | 2020-08-18 12:47:03 | 72       |
# | student_18 | 1.2  | 2020-04-17 03:22:14 | -        |
# | student_18 | 2.2  | 2020-06-18 07:25:44 | 63       |
# | student_18 | 2.4  | 2020-06-18 07:34:14 | 1        |
# | student_20 | 1.2  | 2020-05-28 12:08:53 | -        |
# | student_20 | 2.2  | 2020-06-17 15:55:29 | 21       |
# | student_20 | 2.4  | 2020-06-18 09:48:39 | 1        |
# | student_23 | 1.2  | 2020-05-24 18:15:27 | -        |
# | student_23 | 2.2  | 2020-06-01 04:37:16 | 8        |
# | student_23 | 2.4  | 2020-06-01 04:42:36 | 1        |
# | student_24 | 1.2  | 2020-04-14 16:16:22 | -        |
# | student_24 | 2.2  | 2020-05-11 12:28:49 | 27       |
# | student_24 | 2.4  | 2020-05-13 12:20:39 | 2        |
# | student_27 | 1.2  | 2020-08-12 10:18:47 | -        |
# | student_27 | 2.2  | 2020-08-14 17:14:51 | 3        |
# | student_27 | 2.4  | 2020-08-20 12:23:34 | 6        |
# | student_30 | 1.2  | 2020-08-10 08:38:49 | -        |
# | student_30 | 2.2  | 2020-08-16 12:53:39 | 7        |
# | student_30 | 2.4  | 2020-08-19 11:41:49 | 3        |
# | student_31 | 1.2  | 2020-06-13 09:03:39 | -        |
# | student_31 | 2.2  | 2020-07-02 16:43:36 | 20       |
# | student_31 | 2.4  | 2020-07-05 17:18:56 | 4        |
# | student_36 | 1.2  | 2020-08-04 07:25:30 | -        |
# | student_36 | 2.2  | 2020-08-07 11:39:12 | 4        |
# | student_36 | 2.4  | 2020-08-07 20:33:02 | 1        |
# | student_39 | 1.2  | 2020-05-31 12:35:10 | -        |
# | student_39 | 2.2  | 2020-06-02 09:47:15 | 2        |
# | student_39 | 2.4  | 2020-06-02 17:06:41 | 1        |
# | student_4  | 1.2  | 2020-05-31 17:46:27 | -        |
# | student_4  | 2.2  | 2020-07-27 17:12:45 | 57       |
# | student_4  | 2.4  | 2020-07-29 09:21:24 | 2        |
# | student_43 | 1.2  | 2020-07-16 21:19:13 | -        |
# | student_43 | 2.4  | 2020-08-06 13:02:44 | 21       |
# | student_43 | 2.2  | 2020-08-08 20:11:52 | 3        |
# | student_44 | 1.2  | 2020-05-26 14:23:39 | -        |
# | student_44 | 2.2  | 2020-06-02 11:07:52 | 7        |
# | student_44 | 2.4  | 2020-06-06 21:57:20 | 5        |
# | student_46 | 1.2  | 2020-05-26 13:02:10 | -        |
# | student_46 | 2.4  | 2020-06-03 20:30:01 | 9        |
# | student_46 | 2.2  | 2020-06-03 20:54:34 | 1        |
# | student_49 | 1.2  | 2020-07-11 16:31:12 | -        |
# | student_49 | 2.2  | 2020-07-15 05:00:03 | 4        |
# | student_49 | 2.4  | 2020-07-16 04:57:51 | 1        |
# | student_50 | 1.2  | 2020-07-01 08:16:41 | -        |
# | student_50 | 2.2  | 2020-08-10 08:26:49 | 41       |
# | student_50 | 2.4  | 2020-09-09 12:44:00 | 31       |
# | student_51 | 1.2  | 2020-09-03 07:24:26 | -        |
# | student_51 | 2.2  | 2020-09-07 19:31:01 | 5        |
# | student_51 | 2.4  | 2020-09-10 13:12:11 | 3        |
# | student_52 | 1.2  | 2020-08-24 18:30:55 | -        |
# | student_52 | 2.2  | 2020-09-07 13:51:02 | 14       |
# | student_52 | 2.4  | 2020-09-07 22:16:19 | 1        |
# | student_53 | 1.2  | 2020-07-11 09:32:33 | -        |
# | student_53 | 2.2  | 2020-07-17 12:34:54 | 7        |
# | student_53 | 2.4  | 2020-07-19 05:09:32 | 2        |
# | student_56 | 1.2  | 2020-07-15 12:20:48 | -        |
# | student_56 | 2.2  | 2020-08-06 10:22:13 | 22       |
# | student_56 | 2.4  | 2020-08-20 09:18:46 | 14       |
# | student_59 | 1.2  | 2020-08-17 19:29:09 | -        |
# | student_59 | 2.2  | 2020-08-21 10:35:18 | 4        |
# | student_59 | 2.4  | 2020-08-22 10:39:29 | 2        |
# | student_60 | 1.2  | 2020-09-01 12:54:58 | -        |
# | student_60 | 2.2  | 2020-09-02 15:34:45 | 2        |
# | student_60 | 2.4  | 2020-09-03 10:53:13 | 1        |
# | student_9  | 1.2  | 2020-05-01 05:40:11 | -        |
# | student_9  | 2.2  | 2020-05-05 09:29:20 | 5        |
# | student_9  | 2.4  | 2020-05-06 10:52:38 | 2        |
# +------------+------+---------------------+----------+
# Affected rows: 69

# Важно!
# Чаще всего решение не совпадает для двух записей student_24, шаг 2.2 и student_50, шаг 2.2. Если ответ все
# таки не принимается, то скопируйте таблицу результата и Ваш ответ в EXCEL в соседние столбцы (например, в А и B,
# начиная с первой строки), в ячейке C1 напишите формуле = A1=B1 и протяните ее вниз. Для всех строк, в которых
# данные в столбцах А и B не будут совпадать, в соответствующей ячейке столбца С будет выведено ЛОЖЬ.


WITH
    get_time_lesson (stud, les,  time_max) AS
    (
       SELECT
           student_name,
           CONCAT(module_id,'.',lesson_position),
           MAX(submission_time)
       FROM
           student
           JOIN step_student USING(student_id)
           JOIN step USING (step_id)
           JOIN lesson USING (lesson_id)
       WHERE
           result = 'correct'
       GROUP BY
           student_name, 2
       ORDER BY 1,2
    ),
    get_time_three_lesson(stud_n) AS
    (
      SELECT stud FROM get_time_lesson
      GROUP BY stud HAVING COUNT(*) = 3
    )


SELECT
    stud AS Студент,
    les AS Урок,
    FROM_UNIXTIME(time_max) AS Макс_время_отправки,
    IFNULL(ceil( (time_max - LAG (time_max) OVER (PARTITION BY stud ORDER BY  time_max))/3600/24), '-') AS Интервал
FROM
    get_time_three_lesson
    JOIN get_time_lesson ON stud = stud_n;



# Для студента с именем student_59 вывести следующую информацию по всем его попыткам:
#     информация о шаге: номер модуля, символ '.', позиция урока в модуле, символ '.', позиция шага в модуле;
#     порядковый номер попытки для каждого шага - определяется по возрастанию времени отправки попытки;
#     результат попытки;
#     время попытки (преобразованное к формату времени) - определяется как разность между временем отправки попытки и
#     времени ее начала, в случае если попытка длилась более 1 часа, то время попытки заменить на среднее время всех
#     попыток пользователя по всем шагам без учета тех, которые длились больше 1 часа;
#     относительное время попытки  - определяется как отношение времени попытки (с учетом замены времени попытки) к
#     суммарному времени всех попыток  шага, округленное до двух знаков после запятой  .
#
# Столбцы назвать  Студент,  Шаг, Номер_попытки, Результат, Время_попытки и Относительное_время.
# Информацию отсортировать сначала по возрастанию id шага, а затем по возрастанию номера попытки (определяется по времени
# отправки попытки).
#
# Важно. Все вычисления производить в секундах, округлять и переводить во временной формат только для вывода результата.

WITH res_tab AS
      (
       SELECT
           student_name AS студент,
           CONCAT(module_id, '.', lesson_position, '.', step_position) AS шаг,
           ROW_NUMBER() OVER (PARTITION BY step_id ORDER BY submission_time) AS номер_попытки,
           result AS результат,
           CASE WHEN submission_time - attempt_time > 3600
             THEN (
                    SELECT AVG(submission_time - attempt_time)
                    FROM
                        step_student
                        JOIN student ON
                            step_student.student_id = student.student_id AND
                            student_name = 'student_59'
                        WHERE submission_time - attempt_time <= 3600)
             ELSE
                 submission_time - attempt_time END AS timestamp_attempt,
           step_id,
           submission_time

       FROM
           step_student
           JOIN student ON
                step_student.student_id = student.student_id AND student_name = 'student_59'
           JOIN step USING (step_id)
           JOIN lesson USING (lesson_id))

SELECT
    Студент,
    Шаг,
    Номер_попытки,
    Результат,
    SEC_TO_TIME(ROUND(timestamp_attempt)) AS Время_попытки,
    ROUND(timestamp_attempt / (SUM(timestamp_attempt) OVER (PARTITION BY шаг)) * 100, 2) AS Относительное_время
FROM
    res_tab
ORDER BY
    step_id,
    submission_time;


# Online курс обучающиеся могут проходить по различным траекториям, проследить за которыми можно по способу решения
# ими заданий шагов курса. Большинство обучающихся за несколько попыток  получают правильный ответ
# и переходят к следующему шагу. Но есть такие, что остаются на шаге, выполняя несколько верных попыток, или
# переходят к следующему, оставив нерешенные шаги.
# Выделив эти 'необычные' действия обучающихся, можно проследить их траекторию работы с курсом и проанализировать
# задания, для которых эти действия выполнялись, а затем их как-то изменить.

# Для этой цели необходимо выделить группы обучающихся по способу прохождения шагов:
#     I группа - это те пользователи, которые после верной попытки решения шага делают неверную (скорее всего для
#     того, чтобы поэкспериментировать или проверить, как работают примеры);
#     II группа - это те пользователи, которые делают больше одной верной попытки для одного шага (возможно, улучшают
#     свое решение или пробуют другой вариант);
#     III группа - это те пользователи, которые не смогли решить задание какого-то шага (у них все попытки по этому
#     шагу - неверные).

# Вывести группу (I, II, III), имя пользователя, количество шагов, которые пользователь выполнил по соответствующему
# способу.
# Столбцы назвать Группа, Студент, Количество_шагов.
# Отсортировать информацию по возрастанию номеров групп, потом по убыванию количества шагов и, наконец, по имени
# студента в алфавитном порядке.

# Пояснение
# На основе этого задания я посчитала количество различных обучающихся, относящихся к одной или нескольким группам,
# выделенным в задании. Получилось, что 22 человека из 64 (34%) проходят курс 'нестандартно'.  Причем пересечение
# первой и второй   группы  - 9 человек (почти все, кроме одного человека первой группы входят во вторую), первой и
# третьей группы - пусто, второй и третьей - один человек.

WITH q AS
    (
     SELECT
       student_name,
       step_id,
       SUM(
           CASE
             WHEN result = 'correct'
             THEN 1
             ELSE 0
           END
           ) OVER (PARTITION BY student_name, step_id) AS count_cor,
        (LAG(result) OVER (PARTITION BY student_name, step_id ORDER BY submission_time)) = 'correct'
                AND result = 'wrong' AS is_first
FROM student
     JOIN step_student USING(student_id)
)

SELECT CASE
          WHEN is_first = 1 THEN 'I'
          WHEN count_cor >= 2 THEN 'II'
          WHEN count_cor = 0 THEN 'III'
        END AS 'Группа',
        student_name AS 'Студент',
        COUNT(DISTINCT step_id) AS Количество_шагов
FROM
    q
GROUP BY
    1, 2 HAVING Группа IS NOT NULL
ORDER BY
    1, 3 DESC, 2

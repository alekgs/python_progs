# Создать вспомогательную таблицу applicant, куда включить id образовательной программы,  id абитуриента,
# сумму баллов абитуриентов (столбец itog) в отсортированном сначала по id образовательной программы,
# а потом по убыванию суммы баллов виде (использовать запрос из предыдущего урока).

# Результат
#
# Affected rows: 14
#
# Query result:
# +------------+-------------+------+
# | program_id | enrollee_id | itog |
# +------------+-------------+------+
# | 1          | 3           | 230  |
# | 1          | 2           | 226  |
# | 1          | 1           | 213  |
# | 2          | 6           | 276  |
# | 2          | 3           | 230  |
# | 2          | 2           | 226  |
# | 3          | 6           | 270  |
# | 3          | 4           | 238  |
# | 3          | 5           | 192  |
# | 3          | 1           | 179  |
# | 4          | 6           | 270  |
# | 4          | 3           | 242  |
# | 4          | 5           | 192  |
# | 4          | 1           | 179  |
# +------------+-------------+------+

CREATE TABLE applicant AS
SELECT
       program_id,
       enrollee_id,
       SUM(result) AS itog
FROM
       program_enrollee
       JOIN program_subject  USING(program_id)
       JOIN enrollee_subject USING(enrollee_id, subject_id)
GROUP BY
       program_id,
       enrollee_id
ORDER BY
       program_id,
       itog DESC;

SELECT * FROM applicant;


# Из таблицы applicant,  созданной на предыдущем шаге, удалить записи, если абитуриент на выбранную образовательную
# программу не набрал минимального балла хотя бы по одному предмету (использовать запрос из предыдущего урока).

# Query result:
# +------------+-------------+------+
# | program_id | enrollee_id | itog |
# +------------+-------------+------+
# | 1          | 3           | 230  |
# | 1          | 2           | 226  |
# | 1          | 1           | 213  |
# | 2          | 6           | 276  |
# | 2          | 3           | 230  |
# | 2          | 2           | 226  |
# | 3          | 6           | 270  |
# | 3          | 4           | 238  |
# | 3          | 5           | 192  |
# | 4          | 6           | 270  |
# | 4          | 3           | 242  |
# | 4          | 5           | 192  |
# +------------+-------------+------+
# Affected rows: 12

# Пояснение
# Возможный вариант решения - использование DELETE совместно с USING

# 1
DELETE FROM
    applicant
USING
    applicant
    JOIN program_subject USING(program_id)
    JOIN enrollee_subject USING(enrollee_id, subject_id)
WHERE
    result < min_result;

# 2
DELETE FROM
    applicant
WHERE
    (program_id, enrollee_id) IN
        (
            SELECT
                program_id, enrollee_id
            FROM
                enrollee_subject
                JOIN program_subject USING(subject_id)
            WHERE result < min_result
        );

SELECT * FROM applicant;



# Повысить итоговые баллы абитуриентов в таблице applicant на значения дополнительных баллов
# (использовать запрос из предыдущего урока).

# Query result:
# +------------+-------------+------+
# | program_id | enrollee_id | itog |
# +------------+-------------+------+
# | 1          | 3           | 235  |
# | 1          | 2           | 226  |
# | 1          | 1           | 219  |
# | 2          | 6           | 276  |
# | 2          | 3           | 235  |
# | 2          | 2           | 226  |
# | 3          | 6           | 270  |
# | 3          | 4           | 239  |
# | 3          | 5           | 200  |
# | 4          | 6           | 270  |
# | 4          | 3           | 247  |
# | 4          | 5           | 200  |
# +------------+-------------+------+

#Пояснение

# 1. В запросах на обновление можно использовать несколько связанных таблиц. Например, чтобы обновить поле itog
# таблицы applicant для записей, относящихся к образовательной программе «Прикладная механика», используется запрос:

# UPDATE
#     applicant
#     INNER JOIN program ON applicant.program_id = program.program_id
# SET itog = 2
# WHERE name_program = "Прикладная механика";

# 2. В нашем случае вместо таблицы program можно использовать вложенный запрос, в котором посчитаны дополнительные
# баллы абитуриентов. А в качестве условия соединения таблиц после ключевого слова  ON указать, что id абитуриентов в
# таблице applicant и во вложенном запросе совпадают.

UPDATE
    applicant
    JOIN
        (
          SELECT
                enrollee_id,
                SUM(bonus) AS sum_bonus
          FROM
            enrollee_achievement
            JOIN achievement USING (achievement_id)
          GROUP BY
                enrollee_id
        ) AS q
     USING (enrollee_id)
SET
    itog = itog + sum_bonus;

SELECT * FROM applicant;



# Поскольку при добавлении дополнительных баллов, абитуриенты по каждой образовательной программе могут следовать не в
# порядке убывания суммарных баллов, необходимо создать новую таблицу applicant_order на основе таблицы applicant. При
# создании таблицы данные нужно отсортировать сначала по id образовательной программы, потом по убыванию итогового
# балла. А таблицу applicant, которая была создана как вспомогательная, необходимо удалить.

# Query result:
# +------------+-------------+------+
# | program_id | enrollee_id | itog |
# +------------+-------------+------+
# | 1          | 3           | 235  |
# | 1          | 2           | 226  |
# | 1          | 1           | 219  |
# | 2          | 6           | 276  |
# | 2          | 3           | 235  |
# | 2          | 2           | 226  |
# | 3          | 6           | 270  |
# | 3          | 4           | 239  |
# | 3          | 5           | 200  |
# | 4          | 6           | 270  |
# | 4          | 3           | 247  |
# | 4          | 5           | 200  |
# +------------+-------------+------+

CREATE TABLE applicant_order AS
    SELECT
        *
    FROM
        applicant
    ORDER BY
        program_id,
        itog DESC;

DROP TABLE applicant;

SELECT * FROM applicant_order;

# Включить в таблицу applicant_order новый столбец str_id целого типа , расположить его перед первым.
ALTER TABLE applicant_order ADD str_id INT FIRST;

# Нумерация строк результата запроса
SET @row_num := 0;
SELECT
    *,
    (@row_num := @row_num + 1) AS str_num
FROM  applicant_order;

# Создадим нумерацию, которая начинается заново для каждой образовательной программы.
# Для этого можно использовать алгоритм, в котором в переменную @row_num заносится 1,
# если id программы в предыдущей записи не равен id программы в текущей:

#     объявить переменную @num_pr, задать ей начальное значение;
#     запомнить id образовательной программы для текущей записи в переменной @num_pr;
#     для следующей записи сравнить значение переменной @num_pr с id образовательной программы;
#     если они равны, то продолжить нумерацию @row_num := @row_num + 1;
#     в противном случае начать нумерацию снова, для этого установить @row_num := 1.
#
# Запрос:

SET @num_pr := 0;
SET @row_num := 1;

SELECT *,
     if(program_id = @num_pr, @row_num := @row_num + 1, @row_num := 1) AS str_num,
     @num_pr := program_id AS add_var
FROM applicant_order;
#
# Результат:
#
# +------------+-------------+------+---------+---------+
# | program_id | enrollee_id | itog | str_num | add_var |
# +------------+-------------+------+---------+---------+
# | 1          | 3           | 235  | 1       | 1       |
# | 1          | 2           | 226  | 2       | 1       |
# | 1          | 1           | 219  | 3       | 1       |
# | 2          | 6           | 276  | 1       | 2       |
# | 2          | 3           | 235  | 2       | 2       |
# | 2          | 2           | 226  | 3       | 2       |
# | 3          | 6           | 270  | 1       | 3       |
# | 3          | 4           | 239  | 2       | 3       |
# | 3          | 5           | 200  | 3       | 3       |
# | 4          | 6           | 270  | 1       | 4       |
# | 4          | 3           | 247  | 2       | 4       |
# | 4          | 5           | 200  | 3       | 4       |
# +------------+-------------+------+---------+---------+

# Занести в столбец str_id таблицы applicant_order нумерацию абитуриентов, которая начинается с 1 для каждой
# образовательной программы.

# Пояснение
# В запросе на обновление используйте вложенный запрос , в котором нумеруются записи таблицы applicant_order по
# образовательным программам. В качестве условия соединения таблицы и вложенного запроса после ключевого слова
# указать, что id программ в таблице applicant_order и во вложенном запросе совпадают, а также id абитуриентов в
# таблице applicant_order и во вложенном запросе совпадают.

# Пояснение от Илья Бодня
# В IF можно делать операции над несколькими переменными, используя AND.
# То есть IF(логическое_выражение, выражение AND выражение, выражение)

# Query result:
# +--------+------------+-------------+------+
# | str_id | program_id | enrollee_id | itog |
# +--------+------------+-------------+------+
# | 1      | 1          | 3           | 235  |
# | 2      | 1          | 2           | 226  |
# | 3      | 1          | 1           | 219  |
# | 1      | 2          | 6           | 276  |
# | 2      | 2          | 3           | 235  |
# | 3      | 2          | 2           | 226  |
# | 1      | 3          | 6           | 270  |
# | 2      | 3          | 4           | 239  |
# | 3      | 3          | 5           | 200  |
# | 1      | 4          | 6           | 270  |
# | 2      | 4          | 3           | 247  |
# | 3      | 4          | 5           | 200  |
# +--------+------------+-------------+------+

SET @num_pr := 0;
SET @row_num := 1;

UPDATE
    applicant_order ao
    JOIN
        (
         SELECT
            program_id,
            enrollee_id,
            if(program_id = @num_pr, @row_num := @row_num + 1, @row_num := 1) AS str_num,
            @num_pr := program_id
         FROM
             applicant_order
        ) AS q
    USING (program_id, enrollee_id)
SET
    str_id = str_num;
# WHERE
#     a1.program_id = q.program_id AND
#     a1.enrollee_id = q.enrollee_id;

SELECT * FROM applicant_order;

# Создать таблицу student,  в которую включить абитуриентов, которые могут быть рекомендованы
# к зачислению  в соответствии с планом набора.

# Информацию отсортировать сначала в алфавитном порядке по названию программ,
# а потом по убыванию итогового балла.

# Пояснение
# На каждую образовательную программу может быть зачислено только обозначенное в плане число абитуриентов
# (например, n).
# Выбираются первые n абитуриентов, набравших наибольшее количество баллов. В str_id содержится нумерация
# (отсортированных по сумме баллов абитуриентов), начинающаяся с 1 для каждой образовательной программы. И
# соответственно, если по плану нужно зачислить n абитуриентов, то выбираются все абитуриенты, порядковый номер
# которых в str_id меньше или равен n.

# То есть в таблицу на каждую образовательную программу включить абитуриентов, значение str_id которых в таблице
# applicant_order меньше или равно плану.

# Связанные шаги
#     создание таблицы;
#     соединение таблиц;
#     условие отбора.

# Query result:
# +-------------------------------------+-----------------+------+
# | name_program                        | name_enrollee   | itog |
# +-------------------------------------+-----------------+------+
# | Математика и компьютерные науки     | Степанова Дарья | 276  |
# | Мехатроника и робототехника         | Степанова Дарья | 270  |
# | Мехатроника и робототехника         | Семенов Иван    | 247  |
# | Мехатроника и робототехника         | Попов Илья      | 200  |
# | Прикладная математика и информатика | Семенов Иван    | 235  |
# | Прикладная математика и информатика | Абрамова Катя   | 226  |
# | Прикладная механика                 | Степанова Дарья | 270  |
# | Прикладная механика                 | Яковлева Галина | 239  |
# +-------------------------------------+-----------------+------+
#

CREATE TABLE student AS
    SELECT
        name_program,
        name_enrollee,
        itog
    FROM
        applicant_order a
        JOIN enrollee USING (enrollee_id)
        JOIN program p ON
             a.program_id = p.program_id AND
             a.str_id <= p.plan
    ORDER BY 1,3 DESC;

SELECT * FROM student;

